<!--
    *  'particle equalizer' designed by av(Sehyun Kim)
    *  computer graphics 2015 @itp
    *
    *  av.seoul@gmail.com
    *  http://kimsehyun.kr
    *  
    *  references_
    *  - shader code derived from GPU examples for stack over flow
    *  - https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js
    *
-->

<!DOCTYPE thml>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background: #000;
            }
        </style>
        <!--shaders-->
        <script type="text/javascript" src="src/three.min.js"></script>
        <script type="text/javascript" src="src/stats.min.js"></script>
        <script type="text/javascript" src="src/audioInput.js"></script>
        <script type="text/javascript" src="src/Ps_01.js"></script>
        <script type="text/javascript" src="src/Ps_02.js"></script>
        <script type="text/javascript" src="src/Ps_03.js"></script>
        <script type="text/javascript" src="src/Ps_04.js"></script>
        <script type="text/javascript" src="src/script.js"></script>
        <!--***********************
        *  PS_01_shaders
        *  main particles fluctuating by perlin noise distribution
        ************************-->
        <script type='x-shader/x-vertex' id='PS_01_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            varying vec3 vColor;
            varying float opacityOffset;
            varying float vGb;

            uniform float uTime;
            uniform int uTotalIndices;
            uniform int uIndex;

            attribute float in01;


            void main(){
                float mIn_01 = in01 * .01 + 1.;
                vGb = mIn_01 - 1.;
                opacityOffset = float(uIndex) * 1. / float(uTotalIndices) ;
                vec3 mNormal = normalize( vec3(0.,0.,0.) - position );
                float mNoise = 60. * -2. * noise( mNormal + uTime) * mIn_01;

                //look up vertically 
                vec2 mUv = vec2( 0., .7 - .5 * mNoise );
                float mRgb = mUv.y * ( .02 - .02 * mNoise );
                
                vec3 mPos = position + mNormal * mNoise;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(mPos, 1.0);
                float mPointSize = mRgb * .02;
                mPointSize = clamp(mPointSize, .1, 0.99);
                vColor = vec3(mPointSize, mPointSize, mPointSize);
                gl_PointSize = (1. - mPointSize) * 1.;
            }

        </script>
        <script type='x-shader/x-vertex' id='PS_01_frag'>
            varying vec3 vColor;
            varying float opacityOffset;
            varying float vGb;

            uniform float uC;
            
            void main(){
                vec2 pt = gl_PointCoord - vec2(0.5);
                if(pt.x*pt.x+pt.y*pt.y > 0.25){
                    discard;
                }
                float mC = uC * 0.025;
                vec3 mColor = clamp( vColor, vec3(0., 0., 0.), vec3(1., 1., 1.) );
                gl_FragColor = vec4( (1. - mColor.r) * opacityOffset + vGb * .4 + (1. * mC *(1.- opacityOffset)), 
                vGb * .3 + (.3 * mC *(1.- opacityOffset)), 
                vGb * .1 + (.0 * mC *(1.- opacityOffset)), 
                mColor.r * opacityOffset * 5. );
            }
        </script>

        <!--***********************
        *  PS_02_shaders
        *  tiny details for ps_01
        ************************-->
        <script type='x-shader/x-vertex' id='PS_02_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            uniform float uTime;
            uniform float uIn_01;
            varying float vr;
            varying float vC;

            void main(){
                vec3 mNormal = normalize( vec3(0.,0.,0.) - position );
                float mAlign = 60. * -2. * noise( mNormal + uTime);
                float mNoise = 60. * -2. * noise( position + uTime);
                float mIn_01 = uIn_01 * 0.015;
                vC = mIn_01;
                float mPointSize = 1.;
                if(uIn_01 > 0.){
                    mPointSize = mNoise * .04 * mIn_01;
                } else {
                    mPointSize = mNoise * .02;
                }
                
                vec3 mPos = position + mNormal * (mNoise + mAlign) ;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(mPos, 1.0);
                gl_PointSize = mPointSize;
                vr = mNoise * 0.007;
            }

        </script>
        <script type='x-shader/x-vertex' id='PS_02_frag'>
            varying float vr;
            varying float vC;
            void main(){
                float mC = vC * .4;
                gl_FragColor = vec4( 1. + mC, vr, 0., .99 );
            }
        </script>

        <!--***********************
        *  PS_03_shaders
        *  pop-out particles
        ************************-->
        <script type='x-shader/x-vertex' id='PS_03_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            uniform float uTime;
            uniform float uLife;

            attribute float randomLife;
            attribute float randomLifeTarget;

            varying float vg;
        
            float mRandomLife; 
            vec3 mPos = vec3( 0., 0., 0. );
            vec3 mVel = vec3( 0., 0., 0. );
            vec3 mExplosion = vec3( 0., 0., 0. );
            vec3 mGravity = vec3( 0., 10., 0. );
            

            void main(){
                vec3 mNormal = normalize( vec3(0.,0.,0.) - position );
                float mNoise = 60. * -2. * noise( position );
                                       
                //cal location 
                mExplosion = -.7 * randomLifeTarget * mNormal * (.7 - randomLife/randomLifeTarget);
                mVel = ( mExplosion + mGravity ) * randomLife + mNormal*mNoise;
                mPos = position + mVel;
                float mLNoise = 10. * -.5 * noise( mPos * randomLife );
                mPos = mPos + mNormal * mLNoise;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(mPos, 1.0);
                gl_PointSize = randomLifeTarget * .2 - (randomLife/randomLifeTarget) * randomLifeTarget * .2;
                vg = 1. - (randomLife/randomLifeTarget);
            }

        </script>
        <script type='x-shader/x-vertex' id='PS_03_frag'>
            varying float vg;
            void main(){
                gl_FragColor = vec4( 1., vg*.6, 0., .99 );
                //gl_FragColor = vec4( 1., 0., 0., vg );
            }
        </script>

        <!--***********************
        *  PS_04_shaders
        *  small pop-out particles
        ************************-->
        <script type='x-shader/x-vertex' id='PS_04_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            uniform float uTime;
            uniform float uLife;

            attribute float randomLife;
            attribute float randomLifeTarget;
            attribute float in01;

            varying float alpha;
            varying float gb;
        
            float mRandomLife; 
            vec3 mPos = vec3( 0., 0., 0. );
            vec3 mVel = vec3( 0., 0., 0. );
            vec3 mExplosion = vec3( 0., 0., 0. );
            vec3 mGravity = vec3( 0., 10., 0. );
            
            void main(){
                vec3 mNormal = normalize( vec3(0.,0.,0.) - position );
                float mNoise = 60. * -2. * noise( position + uTime );
                float mIn_01 = pow(in01 * .011, 3.);
                gb = mIn_01 * 0.2;
                                              
                //cal location 
                mExplosion = -.1 * randomLifeTarget * mNormal * (.1 - randomLife/randomLifeTarget);
                mVel = ( mExplosion + mGravity ) * randomLife + mNormal*mNoise;
                mPos = position + mVel;
                float mLNoise = 10. * -.5 * noise( mPos * randomLife );
                mPos = mPos + mNormal * mLNoise;
                
                gl_PointSize = mIn_01 * .5;
                alpha = 1. - randomLife/randomLifeTarget;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(mPos, 1.0);
            }

        </script>
        <script type='x-shader/x-vertex' id='PS_04_frag'>
            varying float alpha;
            varying float gb;
            void main(){
                gl_FragColor = vec4( 1., gb*.1, .0, alpha );
            }
        </script>

        <!--***********************
        *  DS_01_shaders
        *  blob
        ************************-->
        <script type='x-shader/x-vertex' id='DS_01_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            varying float vNoise;
            uniform float uTime;

            void main(){
                //by normal - for big blob
                vNoise = 40. * -2. * noise(normal + uTime * .5);
                //by position - for tiny detail
                float pn = 1. * noise( .015 * position + uTime);
                //compose it
                float displacement = vNoise + pn;

                vec3 mPos = position + normal * displacement;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(mPos, 1.0);
            }
        </script>
        <script type='x-shader/x-vertex' id='DS_01_frag'>
            varying float vNoise;
            uniform sampler2D uTex;
            uniform float uIn_01;
            
            float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}
            
            void main(){
                float mIn_01 = 0.;
                if(uIn_01 > 0.){
                    mIn_01 = uIn_01 * .15;
                } else {
                    mIn_01 = 0.;
                }
                //get a random offset
                float r = .0001 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );
                //look up vertically in the texture
                vec2 mUv = vec2( 0., 1.02 - .32 * vNoise * r );
                
                float mR = mUv.y * ( .2 - .02 * vNoise );
                float mGB = (1. - mUv.y) * ( .05 - .1 * vNoise ) * mIn_01 * .5;
//                if(mGB < 0.){mGB = 0.;}
                //vec3 mColor = vec3( mR + mGB, mGB*.7, mGB*1. ); 
                vec3 mColor = vec3( mR+mGB, mGB*.0, .0 );

                gl_FragColor = vec4( mColor, 1. );
            }
        </script>
        
        <!--***********************
        *  BKG_shaders
        *  background quad
        ************************-->
        <script type='x-shader/x-vertex' id='BKG_vert'>
            varying vec2 vUv;
            void main(){
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        </script>
        <script type='x-shader/x-vertex' id='BKG_frag'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            uniform float uTime;
            varying vec2 vUv;
            void main(){
                float t = 4.5;
                float x = (.5 - vUv.x) * t;
                float y = (.5 - vUv.y) * t/2.;
                float r = x * x + y * y;
                float n = 1. - sqrt(noise(vec2(x, y) + uTime));
                float mRed = 1. - sqrt( r + n );
                gl_FragColor = vec4( vec3(mRed, 0., 0.), 1. );
            }
        </script>
    </head>
    <body>
    </body>
</html>
