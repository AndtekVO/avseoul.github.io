<!--
    *  'particle equalizer' designed by av(Sehyun Kim)
    *  computer graphics 2015 @itp
    *
    *  av.seoul@gmail.com
    *  http://kimsehyun.kr
    *  
    *  references_
    *  - shader code derived from GPU examples for stack over flow
    *  - https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js
    *
-->

<!DOCTYPE thml>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <!--css-->
        <link rel="stylesheet" type="text/css" href="src/mainPage.css">
        <!--libraries-->
        <script type="text/javascript" src="src/three.min.js"></script>
        <script type="text/javascript" src="src/stats.min.js"></script>
        <script src='https://connect.soundcloud.com/sdk/sdk-3.0.0.js'></script>
        <!--scripts-->
        <script type="text/javascript" src="src/mainPage.js"></script>
        <script type="text/javascript" src="src/audioInput.js"></script>
        <script type="text/javascript" src="src/script.js"></script>
        <!--shaders-->
        <script type="text/javascript" src="src/Ps_01.js"></script>
        <script type="text/javascript" src="src/Ps_02.js"></script>
        <script type="text/javascript" src="src/Ps_03.js"></script>
        <script type="text/javascript" src="src/Ps_04.js"></script>
        <script type="text/javascript" src="src/Ps_05.js"></script>
        <!--***********************
        *  PS_01_shaders
        *  main particles fluctuating by perlin noise distribution
        ************************-->
        <script type='x-shader/x-vertex' id='PS_01_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            varying vec4 vColor;

            uniform float uTime;
            uniform int uTotalIndices;
            uniform int uIndex;
            uniform float uTreble;

            attribute float aBass;

            void main(){
                vec3 mNormal = normalize(vec3(0.,0.,0.)-position);
                float mIn01 = aBass*.9+1.;
                float mNoise = 60.*-2.*noise(mNormal+uTime);
                float mO = float(uIndex)/float(uTotalIndices)+.1; //-get custom value 0-1 for opacity based on the order of trails
                //set mTreble
                float mTreble = uTreble;
                if(uTreble == 0.){mTreble = .01;}


                //cal custom v based on vertical height
                float mV = abs(.7-.5*mNoise)*.04; //-set custom uv intensity with treble input
                if(mV<0.001){mV=0.;}else if(mV>1.){mV=1.;} //-clamp custom uv between 0-1                
                mV=pow(mV,3.);
                //set color
                float mBase = aBass*.9;
                if(mBase<0.001){mBase=0.;}else if(mBase>1.){mBase=1.;} //-clamp mBase between 0-1 
                float mR = (1.-mV)*mO*10. - mV*mO + mBase + mTreble*mV*.99+uTreble*aBass; //-root+blackring+base+treble+whity
                float mG = 0. - mV*mO*.5 + mBase + mTreble*mV*1.99+uTreble*aBass; 
                float mB = 0. - mV*mO*.5 + mBase + mTreble*mV*.1+uTreble*aBass;
                float mA = mV*mO*.7+uTreble*aBass*.006;
                vColor = vec4(mR,mG,mB,mA);                
                //set position
                vec3 mPos = position + mNormal*mNoise - mNormal*mIn01;       
                gl_Position = projectionMatrix * modelViewMatrix * vec4(mPos, 1.0);
                //set point size 
                float mPointSize = (1.-mV)*mO;
                mPointSize = pow(mPointSize,2.2)*15.+mBase*.0001+mTreble*.1; //-root+base+treble
                if(mPointSize<0.){mPointSize=0.;}
                gl_PointSize = mPointSize;
            }

        </script>
        <script type='x-shader/x-vertex' id='PS_01_frag'>
            varying vec4 vColor;
            uniform sampler2D uTex;
            
            void main(){
                vec4 mColor = vec4(pow(vColor.rgb,vec3(2.2)), vColor.a); //-gamma correction
                //gl_FragColor = mColor * texture2D(uTex,gl_PointCoord);
                gl_FragColor = mColor;
            }
        </script>

        <!--***********************
        *  PS_02_shaders
        *  tiny details for ps_01
        ************************-->
        <script type='x-shader/x-vertex' id='PS_02_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            attribute float randomTrigger;
            uniform float uTime;
            uniform float uBase;
            varying float vA;
            varying float vG;
            varying float vR;
            void main(){
                //set m variables
                vec3 mNormal = normalize(vec3(0.,0.,0.)-position);
                float mAlign = 60.*-2.*noise(mNormal+uTime);
                float mNoise = 60.*-2.*noise(position+uTime);
                float mBase = uBase*.015;
                //set position
                vec3 mPos = position+mNormal*(mNoise+mAlign);
                gl_Position = projectionMatrix*modelViewMatrix*vec4(mPos,1.0);
                //set pointsize
                float mPointSize = 1.;
                mPointSize = mNoise*.013*mBase;
                mPointSize = pow(mPointSize,2.2);
                if(mPointSize>50.){mPointSize=50.;}
                gl_PointSize = mPointSize;
                //set varying variables
                vA = pow(uBase*.005,2.2);
                vR = mBase;
                vG = mPointSize*.1*randomTrigger;
            }
        </script>
        <script type='x-shader/x-vertex' id='PS_02_frag'>
            varying float vA;
            varying float vG;
            varying float vR;
            uniform sampler2D uTex;
            void main(){
                float mR = vR*.4;
                vec3 mColor = vec3(1.+mR,vG,.0);
                mColor = pow(mColor,vec3(1./2.2));
                //gl_FragColor = vec4(vec3(1.,1.,1.),1.)*texture2D(uTex,gl_PointCoord);
                gl_FragColor = vec4(mColor,vA);
            }
        </script>

        <!--***********************
        *  PS_03_shaders
        *  pop-out particles
        ************************-->
        <script type='x-shader/x-vertex' id='PS_03_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            uniform float uTime;
            uniform float uLife;
            uniform float uBass;
            uniform float uTreble;
            attribute float randomLife;
            attribute float randomLifeTarget;
            attribute float aBass;
            varying float vG;
            varying float vB;
        
            float mRandomLife; 
            vec3 mPos = vec3(0.,0.,0.);
            vec3 mVel = vec3(0.,0.,0.);
            vec3 mExplosion = vec3(0.,0.,0.);
            vec3 mGravity = vec3(0.,10.,0.);

            void main(){
                vec3 mNormal = normalize(vec3(0.,0.,0.)-position);
                float mNoise = 60.*-2.*noise(position);     
                //cal location 
                mExplosion = -.7*randomLifeTarget*mNormal*(.7-randomLife/randomLifeTarget);
                mVel = (mExplosion+mGravity)*randomLife+mNormal*mNoise;
                mPos = position+mVel;
                float mLNoise = 10.*-.5*noise(mPos*randomLife);
                //-set position
                mPos = mPos+mNormal*mLNoise;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(mPos, 1.0);
                //-set point size
                float mPointSize = randomLifeTarget * .2 - (randomLife/randomLifeTarget) * randomLifeTarget * .2;
                if(mPointSize>5.){mPointSize=5.;}
                gl_PointSize = mPointSize;
                //-set varyings
                vG = (1.-(randomLife/randomLifeTarget))*(uBass*.1+1.)+uTreble*aBass;
                vB = uTreble*aBass;
            }

        </script>
        <script type='x-shader/x-vertex' id='PS_03_frag'>
            varying float vG;
            varying float vB;
            void main(){
                vec3 mC = vec3(1.,vG*.1,vB*.1);
                gl_FragColor = vec4(mC,vB*3.);
            }
        </script>

        <!--***********************
        *  PS_04_shaders
        *  small pop-out particles
        ************************-->
        <script type='x-shader/x-vertex' id='PS_04_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            uniform float uTime;
            uniform float uLife;
            uniform float uTreble;
            attribute float randomLife;
            attribute float randomLifeTarget;
            attribute float aBase;
            varying float vA;
            varying float vB;
            varying float vG;
            float mRandomLife; 
            vec3 mPos = vec3(0.,0.,0.);
            vec3 mVel = vec3(0.,0.,0.);
            vec3 mExplosion = vec3(0.,0.,0.);
            vec3 mGravity = vec3(0.,20.,0.);
            void main(){
                vec3 mNormal = normalize( vec3(0.,0.,0.) - position );
                float mNoise = 60. * -2. * noise( position + uTime );
                float mAttrBase = pow(aBase * .011, 3.);
                //-cal location 
                mExplosion = -.1 * randomLifeTarget * mNormal * (.1 - randomLife/randomLifeTarget);
                mVel = ( mExplosion + mGravity ) * randomLife + mNormal*mNoise;
                mPos = position + mVel;
                float mLNoise = 10. * -.5 * noise( mPos * randomLife );           
                //-set point size 
                float mPointSize = mAttrBase*.3+uTreble*2.;
                if(mPointSize<0.){mPointSize=0.;}else if(mPointSize>3.){mPointSize=3.;}
                gl_PointSize = mPointSize;
                //-set position
                mPos = mPos + mNormal * mLNoise;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(mPos, 1.0);
                //-set varying
                vG = pow(mAttrBase,2.2)*.001+uTreble*aBase;
                vB = pow(mAttrBase,2.2)*.0001+uTreble*aBase;
                vA = (1.6-randomLife/randomLifeTarget)*3.;
            }
        </script>
        <script type='x-shader/x-vertex' id='PS_04_frag'>
            varying float vA;
            varying float vG;
            varying float vB;
            void main(){
                gl_FragColor = vec4(1.,vG,vB,vA);
            }
        </script>

        <!--***********************
        *  PS_05_shaders
        *  background starfield
        ************************-->
        <script type='x-shader/x-vertex' id='PS_05_vert'>
            uniform float uTime;
            uniform float uTreble;
            attribute float aBass;
            attribute float randomLife;
            attribute float randomLifeTarget;
            attribute vec2 aVel;
            varying float vGB;
            void main(){
                float mTime = (1.-randomLife/randomLifeTarget)*8.;
                vec3 mLoc = position + vec3(aVel*mTime,-3000.);
                gl_Position = projectionMatrix*modelViewMatrix*vec4(mLoc,1.);
                float mPointSize = 1.+2.*(1.-randomLife/randomLifeTarget);
                gl_PointSize = mPointSize;
                vGB = uTreble*aBass;
            }
        </script>
        <script type='x-shader/x-vertex' id='PS_05_frag'>
            varying float vGB;
            void main(){
                vec3 mC = vec3(1.,vGB*.003,0.);
                gl_FragColor = vec4(mC,.5+vGB);
            }
        </script>

        <!--***********************
        *  DS_01_shaders
        *  blob
        ************************-->
        <script type='x-shader/x-vertex' id='DS_01_vert'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            varying float vNoise;
            uniform float uTime;
            
            void main(){
                //by normal - for big blob
                vNoise = 40. * -2. * noise(normal + uTime * .5);
                //by position - for tiny detail
                float pn = 1. * noise( .015 * position + uTime);
                //compose it
                float displacement = vNoise + pn;
                
                vec3 mPos = position + normal * displacement;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(mPos, 1.0);
            }
        </script>
        <script type='x-shader/x-vertex' id='DS_01_frag'>
            varying float vNoise;
            uniform sampler2D uTex;
            uniform float uIn_01;
            uniform float uTime;
            uniform float uTreble;
            
            float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}
            
            void main(){
                float mIn_01 = uIn_01 * .15;
                //get a random offset
                float r = .0001 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );
                //look up vertically in the texture
                vec2 mUv = vec2( 0., 1.02 - .32 * vNoise * r );
                
                float mR = mUv.y * ( .2 - .02 * vNoise );
                float mGB = (1. - mUv.y) * ( .05 - .1 * vNoise ) * mIn_01 * .8;
                //if(mGB < 0.){mGB = 0.;}
                float mEnergy = mGB * uTreble * .5;
                vec3 mColor = vec3( mR + mGB * 1. + mEnergy, mGB*.0 + mEnergy, mGB*.0 + mEnergy*.1 ); 
                mColor = pow(mColor,vec3(2.2));//-gamma correction, you will lose vertically shading

                gl_FragColor = vec4( mColor, 1. );
            }
        </script>
        
        <!--***********************
        *  BKG_shaders
        *  background quad
        ************************-->
        <script type='x-shader/x-vertex' id='BKG_vert'>
            varying vec2 vUv;
            void main(){
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        </script>
        <script type='x-shader/x-vertex' id='BKG_frag'>
            //noise, tubulence, fractal algorithm by Ken Perlin
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
            float noise(vec3 P) {
                vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
                vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
                vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
                vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
                vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0); gx1 = fract(gx1);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
                g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
                g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
                g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
                vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
                g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
                g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
                vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
                return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
            }
            float noise(vec2 P) { return noise(vec3(P, 0.0)); }
            float fractal(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += noise(s * P) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }
            float turbulence(vec3 P) {
                float f = 0., s = 1.;
                for (int i = 0 ; i < 9 ; i++) {
                    f += abs(noise(s * P)) / s;
                    s *= 2.;
                    P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
                }
                return f;
            }

            uniform float uTime;
            uniform float uIn_01;
            uniform float uTreble;
            varying vec2 vUv;

            void main(){
                float mi = uIn_01 * .0001;
                float t = 3.0 - (3.0 * uTreble * .3);
                float x = (.5 - vUv.x) * t;
                float y = (.5 - vUv.y) * t/2.;
                float r = x * x + y * y;
                float n = 1. - sqrt(noise(vec2(x, y) + uTime*.3 + mi));
                float mRed = 1. - sqrt( r + n ) + uTreble*.2;
                vec3 mC = vec3(mRed*.5,.0,.0);
                //mC = pow(mC,vec3(2.2));//-gamma correction
                gl_FragColor = vec4( mC, 1. );
            }
        </script>
    </head>
    <body>
        <div id='project-title'><span>Particle Equalizer #1</span></div>
        <div id='description'>
            <div class='body-title'><span>_description</span></div>
            <span class='body-description'>'Particle Equalizer #1' is the first experiemnt project of 'Particle Equalizer Series' by 'sehyun kim' (also known as 'av' or 'visualozik'). <br />Created in 'Nature Of Code 2015 by Mimi Yin' & 'Computer Graphics 2015 by Ken Perlin' at ITP (Interactive Telecommunications Program), NYU.<br/> Inspired by 'Robert Hodgin (flight404)'s audiovisual generative coding works.
                <br/><br/>
                <font style='line-height:10px;'>*this app only runs in <font style='color:#d30;'>chrome browser</font><br/></font>
            </span>
        </div>
        <div id='project-info'>
            <div class='body-title'><span>_project info</span></div>
            <span class='body-description'>
                <li><span>javascript/ web-audio-api/ <a href='http://threejs.org/' target='_blank'>threejs</a>/ glsl/ soundcloud-api/ css</span></li>
                <li><span>web application for desktop</span></li>
                <li><span>creative coding</span></li>
                <li><span>sound reactive</span></li>
                <li><span>2015.12</span></li>
            </span>
        </div>
        <div id='contact-info'>
            <div class='body-title'><span>_artist info</span></div>
            <span class='body-description'>
                sehyun kim (a.k.a av&visualozik)<br/>
                av.seoul@gmail.com<br />
                <a href='http://kimsehyun.kr' target='_blank'>http://kimsehyun.kr</a><br />
            </span>
        </div>
        <div id='bgm'>
            <div class='player' id='player-here'></div>
        </div>

    </body>
</html>
